<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.0">Jekyll</generator><link href="http://ytoku.net/feed.xml" rel="self" type="application/atom+xml" /><link href="http://ytoku.net/" rel="alternate" type="text/html" /><updated>2017-08-18T08:58:00+00:00</updated><id>http://ytoku.net/</id><title type="html">enhance my world</title><subtitle>write tips help be clear</subtitle><author><name>yto9</name></author><entry><title type="html">lower software layer meetup</title><link href="http://ytoku.net/technology/candle-lower-software-layer/" rel="alternate" type="text/html" title="lower software layer meetup" /><published>2017-08-18T00:00:00+00:00</published><updated>2017-08-18T00:00:00+00:00</updated><id>http://ytoku.net/technology/candle-lower-software-layer</id><content type="html" xml:base="http://ytoku.net/technology/candle-lower-software-layer/">&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#meetupについて&quot; id=&quot;markdown-toc-meetupについて&quot;&gt;meetupについて&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#経緯&quot; id=&quot;markdown-toc-経緯&quot;&gt;経緯&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#目的&quot; id=&quot;markdown-toc-目的&quot;&gt;目的&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#メイントピック&quot; id=&quot;markdown-toc-メイントピック&quot;&gt;メイントピック&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#注&quot; id=&quot;markdown-toc-注&quot;&gt;注&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#情報システムの複雑性と簡便性&quot; id=&quot;markdown-toc-情報システムの複雑性と簡便性&quot;&gt;情報システムの複雑性と簡便性&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#コンピュータプログラムの実行&quot; id=&quot;markdown-toc-コンピュータプログラムの実行&quot;&gt;コンピュータプログラムの実行&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#実行するのはだれか&quot; id=&quot;markdown-toc-実行するのはだれか&quot;&gt;実行するのはだれか&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#命令セット&quot; id=&quot;markdown-toc-命令セット&quot;&gt;命令セット&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#我々の使用しているコンピュータ&quot; id=&quot;markdown-toc-我々の使用しているコンピュータ&quot;&gt;我々の使用しているコンピュータ&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cpuの言語&quot; id=&quot;markdown-toc-cpuの言語&quot;&gt;CPUの言語&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#バイナリbinary&quot; id=&quot;markdown-toc-バイナリbinary&quot;&gt;バイナリ(binary)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cpuが扱えるものはバイナリのみ&quot; id=&quot;markdown-toc-cpuが扱えるものはバイナリのみ&quot;&gt;CPUが扱えるものはバイナリのみ&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#テキストは人間用&quot; id=&quot;markdown-toc-テキストは人間用&quot;&gt;テキストは人間用&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#プログラミング言語と処理系&quot; id=&quot;markdown-toc-プログラミング言語と処理系&quot;&gt;プログラミング言語と処理系&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#demo&quot; id=&quot;markdown-toc-demo&quot;&gt;demo&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ノイマン型の特徴&quot; id=&quot;markdown-toc-ノイマン型の特徴&quot;&gt;ノイマン型の特徴&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ハードウェアから見えるセカイ&quot; id=&quot;markdown-toc-ハードウェアから見えるセカイ&quot;&gt;ハードウェアから見えるセカイ&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#基本原則&quot; id=&quot;markdown-toc-基本原則&quot;&gt;基本原則&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#なんでディジタルなのか&quot; id=&quot;markdown-toc-なんでディジタルなのか&quot;&gt;なんでディジタルなのか&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#設計の容易さ&quot; id=&quot;markdown-toc-設計の容易さ&quot;&gt;設計の容易さ&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#論理回路はトランジスタによって電子回路として実装される&quot; id=&quot;markdown-toc-論理回路はトランジスタによって電子回路として実装される&quot;&gt;論理回路はトランジスタによって電子回路として実装される&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#osの役割&quot; id=&quot;markdown-toc-osの役割&quot;&gt;OSの役割&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#特権&quot; id=&quot;markdown-toc-特権&quot;&gt;特権&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cpuを仮想化スレッドプロセス&quot; id=&quot;markdown-toc-cpuを仮想化スレッドプロセス&quot;&gt;CPUを仮想化:スレッド・プロセス&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#スレッド&quot; id=&quot;markdown-toc-スレッド&quot;&gt;スレッド&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#プロセス&quot; id=&quot;markdown-toc-プロセス&quot;&gt;プロセス&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;meetupについて&quot;&gt;meetupについて&lt;/h2&gt;
&lt;h3 id=&quot;経緯&quot;&gt;経緯&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/gline.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;完全に腹落ち&lt;/strong&gt;・&lt;strong&gt;最終的&lt;/strong&gt;・&lt;strong&gt;全体像&lt;/strong&gt;から，&lt;br /&gt;
このmeetup内の理解で既存の情報システムの大部分を&lt;strong&gt;大局的に&lt;/strong&gt;把握出来るように，&lt;br /&gt;
あまり一般的なソフトウェアプログラマが意識していないであろうトピックを選びました．&lt;/p&gt;

&lt;h3 id=&quot;目的&quot;&gt;目的&lt;/h3&gt;
&lt;p&gt;パソコンと仲良くなる．&lt;/p&gt;

&lt;h3 id=&quot;メイントピック&quot;&gt;メイントピック&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;コンピュータ&lt;/strong&gt;&lt;strong&gt;プログラム&lt;/strong&gt;の&lt;strong&gt;実行&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;このシンプルな一文について，掘り下げていく(掘り下げられるようにする)．&lt;/p&gt;

&lt;p&gt;このトピックに沿って，情報システムを概観し，&lt;br /&gt;
meetupが終わった時に，少しでも皆さんのディジタルワールドの解像度が上がればいいなと思って話します．&lt;/p&gt;

&lt;p&gt;プログラムの実行に&lt;strong&gt;CPU&lt;/strong&gt;・&lt;strong&gt;OS&lt;/strong&gt;がどのように関わっているかをメインに据えます．&lt;/p&gt;

&lt;h4 id=&quot;注&quot;&gt;注&lt;/h4&gt;
&lt;p&gt;今日扱う話は死ぬほど広範囲に渡る話です．
学問領域で言うと，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;コンピュータアーキテクチャ&lt;/li&gt;
  &lt;li&gt;ディジタル回路設計&lt;/li&gt;
  &lt;li&gt;論理回路&lt;/li&gt;
  &lt;li&gt;電子回路&lt;/li&gt;
  &lt;li&gt;(OS)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;辺りに触れます．
定義・証明まみれにならないように敢えて専門用語を避けたり抽象的に話します．&lt;/p&gt;

&lt;h3 id=&quot;情報システムの複雑性と簡便性&quot;&gt;情報システムの複雑性と簡便性&lt;/h3&gt;
&lt;p&gt;情報システムは，ハードウェア，ソフトウェアのそれぞれが複数の階層に別れています．&lt;br /&gt;
その各層のインターフェースが各層のモジュールの汎用性を保つように設計されたことにより，それぞれの層で多数の概念が生まれ，それぞれが学問の一分野になるほど発展しています．
情報システム界全体の複雑さは各層での各モジュールの組み合わせです．
情報システムは各層の実装ではなく，使い方(インターフェース)さえ分かればどんな高度な技術でも利用できます，優しいセカイ．&lt;/p&gt;

&lt;h2 id=&quot;コンピュータプログラムの実行&quot;&gt;コンピュータプログラムの実行&lt;/h2&gt;

&lt;p&gt;コンピュータプログラムの実行のイメージは人によって違うと思います．&lt;/p&gt;

&lt;p&gt;スマホアプリ・Word・エディタ・ブラウザ・シェル・OS・… ，全てコンピュータプログラムです．&lt;br /&gt;
アプリケーションが起動している時，そのアプリケーションのプログラムは実行されているといいます．&lt;/p&gt;

&lt;p&gt;今日は折角低レイヤー勉強会なので，意識されることの少ない(必ずしも意識する必要はない)ブラックボックスの内側に目を向けてみましょう．&lt;/p&gt;

&lt;h3 id=&quot;実行するのはだれか&quot;&gt;実行するのはだれか&lt;/h3&gt;
&lt;p&gt;今回は，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;コンピュータ&lt;/strong&gt;がプログラムを実行する&lt;/p&gt;

&lt;p&gt;としましょう．&lt;br /&gt;
ex. スマホアプリの場合&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;人がアプリをタッチ&lt;/li&gt;
  &lt;li&gt;タッチをスマホのOSが検知&lt;/li&gt;
  &lt;li&gt;OSがコンピュータにアプリの実行を指示&lt;/li&gt;
  &lt;li&gt;コンピュータがアプリを実行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このように任意のプログラムは，”最終的に”コンピュータが実行します．&lt;/p&gt;

&lt;h3 id=&quot;命令セット&quot;&gt;命令セット&lt;/h3&gt;
&lt;p&gt;人が何かを実行する場合，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;食べる&lt;/li&gt;
  &lt;li&gt;考える&lt;/li&gt;
  &lt;li&gt;寝る&lt;/li&gt;
  &lt;li&gt;etc…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;のようにバリエーションは多岐にわたります．&lt;/p&gt;

&lt;p&gt;コンピュータの場合はどうでしょうか．&lt;/p&gt;

&lt;p&gt;実は，出来る行動(処理)が予め決まっています．
これを，&lt;strong&gt;命令セット&lt;/strong&gt;と言います．&lt;/p&gt;

&lt;h3 id=&quot;我々の使用しているコンピュータ&quot;&gt;我々の使用しているコンピュータ&lt;/h3&gt;
&lt;p&gt;普段接しているコンピュータがどういったものなのか考えてみましょう．&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ディジタルコンピュータ&lt;/li&gt;
  &lt;li&gt;ノイマン型コンピュータ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ノイマン型は聞いたことがない人もいるかもしれないが，&lt;br /&gt;
記述されたプログラムを実行するという形式をとっているコンピュータはノイマン型です．&lt;/p&gt;

&lt;p&gt;コンピュータをノイマン型コンピュータと認識することで初めて，ソフトウェアという概念が出てきます．&lt;/p&gt;

&lt;p&gt;cf.非ノイマン型コンピュータ&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;コンピュータ&lt;/strong&gt;がプログラムを実行する&lt;br /&gt;
-&amp;gt; (updated)&lt;strong&gt;CPU&lt;/strong&gt;が&lt;strong&gt;メモリ&lt;/strong&gt;上にあるプログラムを実行する&lt;/p&gt;

&lt;h2 id=&quot;cpuの言語&quot;&gt;CPUの言語&lt;/h2&gt;
&lt;h3 id=&quot;バイナリbinary&quot;&gt;バイナリ(binary)&lt;/h3&gt;

&lt;p&gt;バイナリという単語は，2進数による表示形式を指す場合と，テキストファイル以外を指す場合があるようです．&lt;/p&gt;

&lt;h3 id=&quot;cpuが扱えるものはバイナリのみ&quot;&gt;CPUが扱えるものはバイナリのみ&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ファイル&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  - データ(動画，音声，テキスト, …)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;OS (検証・後述)&lt;/li&gt;
  &lt;li&gt;etc..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ほんとに？&lt;/p&gt;
&lt;h3 id=&quot;テキストは人間用&quot;&gt;テキストは人間用&lt;/h3&gt;
&lt;p&gt;普段書いてるプログラムはtextだ！&lt;/p&gt;

&lt;p&gt;-&amp;gt; 見てみよう&lt;/p&gt;

&lt;h3 id=&quot;プログラミング言語と処理系&quot;&gt;プログラミング言語と処理系&lt;/h3&gt;
&lt;h4 id=&quot;demo&quot;&gt;demo&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;text&lt;/li&gt;
  &lt;li&gt;Cprogram&lt;/li&gt;
  &lt;li&gt;object file&lt;/li&gt;
  &lt;li&gt;実行ファイル&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ノイマン型の特徴&quot;&gt;ノイマン型の特徴&lt;/h3&gt;
&lt;p&gt;ノイマン型は演算器，記憶装置，ソフトウエアと切り分けが明確であり，それぞれの専業が分担して開発できる．
インターフェースさえ画定されていれば，それぞれの分野で独自の技術的発展が可能である&lt;/p&gt;

&lt;p&gt;ここまではソフトウェア側からハードウェアとのインターフェースを見てきました．&lt;/p&gt;

&lt;p&gt;次はハードウェアからソフトウェアとのインターフェースを見てみましょう．&lt;/p&gt;

&lt;h2 id=&quot;ハードウェアから見えるセカイ&quot;&gt;ハードウェアから見えるセカイ&lt;/h2&gt;
&lt;h3 id=&quot;基本原則&quot;&gt;基本原則&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;入力&lt;/li&gt;
  &lt;li&gt;演算&lt;/li&gt;
  &lt;li&gt;出力&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;なんでディジタルなのか&quot;&gt;なんでディジタルなのか&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ベースとなる論理回路は死ぬほど単純 -&amp;gt; 設計が容易&lt;/li&gt;
  &lt;li&gt;論理回路を実装するロジックで最強なのがトランジスタ(小さくて高速低燃費)&lt;/li&gt;
  &lt;li&gt;ディジタルコンピュータは情報のディジタル化を促進する&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;設計の容易さ&quot;&gt;設計の容易さ&lt;/h3&gt;
&lt;p&gt;論理回路 完全性 検索&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AND&lt;/li&gt;
  &lt;li&gt;OR&lt;/li&gt;
  &lt;li&gt;NOT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の組み合わせで任意のn入力論理回路を設計できる．&lt;/p&gt;

&lt;h3 id=&quot;論理回路はトランジスタによって電子回路として実装される&quot;&gt;論理回路はトランジスタによって電子回路として実装される&lt;/h3&gt;

&lt;p&gt;ここまでの話でコンピュータはプログラムの実行が出来る．&lt;br /&gt;
しかし，このままでは，一つのプログラムが終わるまで他のプログラムが実行できない．&lt;/p&gt;

&lt;p&gt;今日はここまでかな&lt;/p&gt;
&lt;h2 id=&quot;osの役割&quot;&gt;OSの役割&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;コンビニとしてのOS
      - 計算機資源の抽象化
              - 生のハードウェアは利用困難
              - 簡便に使えるように関数群を提供 -&amp;gt; システムコールを呼び出すだけ
      - 計算機資源の仮想化
              - CPUやメモリを他のプログラムを意識せず使える&lt;/li&gt;
  &lt;li&gt;警察としてのOS
      - プロセスの隔離
              - 他のプログラムがデータを盗んだり破壊したりしない． 
      - 計算機資源の管理
              - 一つのプログラムがCPUやメモリを独占できないようにする &amp;lt;- システムコールからしかアクセスできない&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;特権&quot;&gt;特権&lt;/h3&gt;
&lt;p&gt;入出力と一部のメモリ領域へのアクセス命令はCPUの特権モードでしか使えない&lt;/p&gt;

&lt;h3 id=&quot;cpuを仮想化スレッドプロセス&quot;&gt;CPUを仮想化:スレッド・プロセス&lt;/h3&gt;
&lt;p&gt;物理的なCPUは十個程度
        - 数百のプログラムを立ち上げることが出来る&lt;/p&gt;
&lt;h3 id=&quot;スレッド&quot;&gt;スレッド&lt;/h3&gt;
&lt;p&gt;OSはスレッドにCPUを割り当て実行
OSが交互に実行&lt;/p&gt;
&lt;h3 id=&quot;プロセス&quot;&gt;プロセス&lt;/h3&gt;</content><author><name>yto9</name></author><category term="OS" /><summary type="html">meetupについて 経緯 meetupについて 経緯</summary></entry><entry><title type="html">『コンピュータプログラミングの概念・技法・モデル』(CTMCP)を読む 01 はじめに，環境構築</title><link href="http://ytoku.net/technology/ctmcp-study-log-01/" rel="alternate" type="text/html" title="『コンピュータプログラミングの概念・技法・モデル』(CTMCP)を読む 01 はじめに，環境構築" /><published>2017-07-29T00:00:00+00:00</published><updated>2017-07-29T00:00:00+00:00</updated><id>http://ytoku.net/technology/ctmcp-study-log-01</id><content type="html" xml:base="http://ytoku.net/technology/ctmcp-study-log-01/">&lt;p&gt;&lt;a href=&quot;../ctmcp-study-log-00&quot;&gt;前回&lt;/a&gt;は自分の目的がメインだったが，今回からは本の内容に入っていく．&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#読んだ範囲&quot; id=&quot;markdown-toc-読んだ範囲&quot;&gt;読んだ範囲&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#感想&quot; id=&quot;markdown-toc-感想&quot;&gt;感想&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#特徴制約&quot; id=&quot;markdown-toc-特徴制約&quot;&gt;特徴・制約&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ozを採用している理由&quot; id=&quot;markdown-toc-ozを採用している理由&quot;&gt;Ozを採用している理由&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#演習環境構築&quot; id=&quot;markdown-toc-演習環境構築&quot;&gt;演習環境構築&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;読んだ範囲&quot;&gt;読んだ範囲&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.amazon.co.jp/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E6%A6%82%E5%BF%B5%E3%83%BB%E6%8A%80%E6%B3%95%E3%83%BB%E3%83%A2%E3%83%87%E3%83%AB-Architects-Archive%E3%82%AF%E3%83%A9%E3%82%B7%E3%83%83%E3%82%AF%E3%83%A2%E3%83%80%E3%83%B3%E3%83%BB%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0-%E3%82%BB%E3%82%A4%E3%83%95%E3%83%BB%E3%83%8F%E3%83%AA%E3%83%87%E3%82%A3/dp/4798113468&quot;&gt;『コンピュータプログラミングの概念・技法・モデル』&lt;/a&gt;(p.iii-p.xx)の”はじめに”を読んだ．&lt;br /&gt;
この本の位置づけ・目的，学問としてのコンピュータプログラミングとその学習法など，著者のプログラミングに対する思想が述べられている．&lt;/p&gt;

&lt;h2 id=&quot;感想&quot;&gt;感想&lt;/h2&gt;
&lt;p&gt;“はじめに”だけで非常に感銘を受けた．&lt;br /&gt;
著者のプログラミング教育に対する熱意が伺え，興味深い話も多々あった．
全部を引用するとただの”はじめに”になってしまいそうなので，ここでの引用は最小限に留める．
公式に公開されているものなのか分からないのでリンクを貼るのは避けるが，英語版のpdfならweb上で見つかる．本を持っていない人は，そこでPrefaceだけ目を通し，気に入ったら書籍を購入すると良いと思う．&lt;/p&gt;

&lt;p&gt;“はじめに”を読んで自分が強く感じたのは以下である．&lt;/p&gt;

&lt;p&gt;プログラミングは，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;統合的な学問&lt;/li&gt;
  &lt;li&gt;科学であり技術&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;である．しかし，大概の場合&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;小手先仕事(単なる技術)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;として教えられている．ということだ．
著者はどちらの側面も否定していない．
著者は”はじめに”の中で，プログラミング教育に対して以下のように述べている．&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;技術がかけると純粋数学と変わらないことになる．科学が欠けると小手先仕事になる．すなわち，深い理解に欠ける．よって，プログラミングを正しく教えるとは，技術(現在のツール)と科学(基礎的概念)とを共に教えることである．学生がツールを知ることは現在に対する備えであり，概念を知ることは将来の発展に対する備えである．&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;「将来の発展に対する備え」，持続可能性の高そうなものが好きな自分はここを読んで非常に高まった．
著者が想定している例にもれず，自分は小手先仕事としていくつかの言語からプログラミングを学んできたタイプだが，”はじめに”を読む限り，この本を読み始めるにあたって，いわゆるプログラミング経験は前提としていないようだ．また，初学者がボトムアップで，プログラミングの概念を学習していくことが現実的ではないことにも言及しており，理論理論した構成ではないことが伺えた．&lt;br /&gt;
主にこのシリーズは自分の学習記録用だが，このシリーズを読んでCTMCPでプログラミングを学習してみようと思う人がいたら嬉しい(コンピュータ・サイエンスに詳しい優秀なプログラマが増え，世の中に本質的な情報が溢れるといいなと常々思っている)．&lt;/p&gt;

&lt;h2 id=&quot;特徴制約&quot;&gt;特徴・制約&lt;/h2&gt;
&lt;p&gt;言語的な制約などに縛られない，体系的なプログラミングについての本であるが，プログラミングの教授法としては計算ベースの方法を採用している．
そのため利用する言語Ozによる形式化のみは行われる．&lt;/p&gt;

&lt;h3 id=&quot;ozを採用している理由&quot;&gt;Ozを採用している理由&lt;/h3&gt;
&lt;p&gt;概念の説明に，本の中で利用する言語にOzを選んだ理由としては以下が挙げられていた．&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;核言語方式に従っている&lt;/li&gt;
  &lt;li&gt;Mozart Programming Systemが存在している&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.info.ucl.ac.be/~pvr/fdpefinalweb.pdf&quot;&gt;核言語&lt;/a&gt;による計算モデルの理解がこの本の肝であるようだ．
日本語で核言語(kernel language/core language)についてまとまっている情報源が見当たらなかったので，著者による核言語による教授法についての論文へのリンクを貼っておく．
本書での勉強を終えたら別途，自分の理解をまとめようと思う．&lt;/p&gt;

&lt;h2 id=&quot;演習環境構築&quot;&gt;演習環境構築&lt;/h2&gt;
&lt;p&gt;この本はMozart 1系(1.1.0による実行結果などが添付されている)が想定されて書かれている．&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;この本では，第13章(一般的計算モデル)と第12章(計算空間)によって与えられる意味を持つ，理想的な実装を前提としている．この理想的な実装とMozartシステムとの間には若干の差異がある．そのことについてはこの本のウェブサイトに説明がある．&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;とあり，そのウェブサイトは&lt;a href=&quot;https://www.info.ucl.ac.be/~pvr/book.html&quot;&gt;ここ&lt;/a&gt;である．
公式サイトはあまり見やすいものではなかったので，色々と調べていると演習環境について著者が答えているメーリスの&lt;a href=&quot;https://groups.google.com/forum/#!topic/mozart-users/AilSIdmcB_k&quot;&gt;スレッド&lt;/a&gt;を見つけた．&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/peter.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本中の全ての演習が実行できるようにしたかったのでこの指示に従い，Mozart1.4.0の環境を構築することにした．
自分はUbuntu16.04(x86_64)を使っており公式のMozartのパッケージは&lt;a href=&quot;https://help.ubuntu.com/community/Mozart&quot;&gt;色々問題がありそうな雰囲気&lt;/a&gt;だったので，Ubuntu16.04(x64)の仮想環境を用意した．
インストールは，&lt;a href=&quot;https://github.com/mozart/mozart&quot;&gt;Githubのリポジトリ&lt;/a&gt;のREADMEに従った．
READMEでは，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Arch linux&lt;/li&gt;
  &lt;li&gt;Ubuntu/Debian(x64)&lt;/li&gt;
  &lt;li&gt;OS X&lt;/li&gt;
  &lt;li&gt;OS X(x86_64)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が想定されているので自分の環境にあったインストール手順を踏む．
自分の場合はUbuntu(x64)なので以下．&amp;lt;username&amp;gt; は適宜自分のpcのlogin user名に変換．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install emacs flex bison tk-dev build-essential g++-multilib zlib1g-dev:i386 libgmp-dev:i386
$ mkdir -p ~/dev
$ cd ~/dev
$ git clone git://github.com/mozart/mozart.git
$ cd ~/dev/mozart
$ ./configure --prefix=/home/&amp;lt;username&amp;gt;/oz --disable-contrib-gdbm --enable-modules-static
$ make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;~/.profileにozのバイナリへのパスを追加．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo &quot;export OZHOME=/home/&amp;lt;username&amp;gt;/oz&quot; &amp;gt;&amp;gt; ~/.profile
$ echo &quot;export PATH=$PATH:$OZHOME/bin&quot; &amp;gt;&amp;gt; ~/.profile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;プロファイルの内容を読みこませるために再起動すると無事ozとMozartの起動が確認できた．
&lt;img src=&quot;/assets/img/oz_env.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>yto9</name></author><category term="Books" /><category term="CTMCP" /><category term="Log" /><summary type="html">前回は自分の目的がメインだったが，今回からは本の内容に入っていく． 読んだ範囲 読んだ範囲 『コンピュータプログラミングの概念・技法・モデル』(p.iii-p.xx)の”はじめに”を読んだ． この本の位置づけ・目的，学問としてのコンピュータプログラミングとその学習法など，著者のプログラミングに対する思想が述べられている．</summary></entry><entry><title type="html">『コンピュータプログラミングの概念・技法・モデル』(CTMCP)を読む 00 モチベーション，経緯</title><link href="http://ytoku.net/technology/ctmcp-study-log-00/" rel="alternate" type="text/html" title="『コンピュータプログラミングの概念・技法・モデル』(CTMCP)を読む 00 モチベーション，経緯" /><published>2017-07-28T00:00:00+00:00</published><updated>2017-07-28T00:00:00+00:00</updated><id>http://ytoku.net/technology/ctmcp-study-log-00</id><content type="html" xml:base="http://ytoku.net/technology/ctmcp-study-log-00/">&lt;p&gt;これまでにいくつかのプログラミング言語でプログラミングをしてきた．&lt;br /&gt;
初めてプログラミングを学んだのはC言語を用いてだった．
C言語は現在ある高級言語の中ではシンプルな部類に入る言語である．
言語を構成している概念は少ない方だとは思うが，それでもプログラミングが初めての自分にとっては初めての概念ばかりだった．
それなりに壁にぶつかりつつも色々とプログラミングについての知見を得ることができていると思っていた．&lt;/p&gt;

&lt;p&gt;その後，web開発などで様々な言語に触れた後に，C言語のコンパイラを作る機会があった．&lt;br /&gt;
既存のCコンパイラ(gcc, clang)には各種性能で敵わなかった．
世の中のプログラマは優秀だなと思う一方で，ソフトウェアは結局機械語が走ってるだけなんだなと実感できた．
しかし，そう思い始めてから特定の言語にのめり込んで標準ライブラリや次々と出てくる3rd partyのライブラリのサポートする関数の種類や使い方を知ること，つまり特定の言語に詳しくなることに魅力をを感じなくなってきてしまった．&lt;/p&gt;

&lt;p&gt;自分は英語を学ぶことが好きである．&lt;br /&gt;
なぜなら，話者が非常に多く，多くの情報源が英語で記述，もしくは英語に翻訳されアクセス出来る状態になっているからである．
今後も，今現在英語を用いている人々が突然全滅することがない限り，自分が生きている数十年オーダの間は突如世界から失われたりしない言語だと個人的には思っている．&lt;/p&gt;

&lt;p&gt;しかし，特定のプログラミング言語はどうだろうか．&lt;/p&gt;

&lt;p&gt;ソフトウェアは後方互換性を保ったまま進化をするのが良しとされている．プログラミング言語もその例に漏れてはいないように思う．
しかし，それはあくまで同一系譜内の話である．
新しい言語が出てくる場合に受け継がれていくものは，その前世代に開発者やユーザに価値を認められた言語の中で，真に有用だった核となる機構(+新たな?概念)だけである．
特定の言語の仔細(多くの場合には本質的ではないが，その特定の言語による制約が故に煩雑になっている部分)にはどれほどの価値があるのだろうか．&lt;/p&gt;

&lt;p&gt;現在流行っている言語達は非常にハイスペックである．&lt;br /&gt;
ライブラリの内部実装はバグが起きたり，改良したいと思わない限り，多くのユーザはほとんど目を通さないで済む(これ自体は非常にいいことである)．
しかし，無意識にプログラミングをしていると自分が作ったアプリケーションの大部分がブラックボックス化してしまう．
Ruby on rails・CakePHP・Django のようなweb frameworkなどはその最たる例である．
初学者は自分がrubyの標準ライブラリを呼んでいるのかframeworkのコンポーネントを用いているのか，frameworkが提供しているライフサイクルはどうなっているか，ブラウザとは何か等々は知らなくても最低限動くものは作れてしまうのである．
もちろん，全てにおいて1から10まで把握すればいいというものではない．プログラミングに限らず現代の進んだ科学技術に対しては全てを把握することは，現実的な話ではない．
しかし，自分は自分の使うものは，ホワイトボックスとは行かずともせめて箱の中にどういったものが入ってるのかくらいは知っておきたいのである．
ハイスペックな言語(+各種ライブラリ，framerwork)が手厚くプログラマをサポートしてくれればくれるほど，無意識に特定のプログラミング言語を扱っているだけではその核を構成している概念の理解に到達しづらくなっていると感じる．&lt;/p&gt;

&lt;p&gt;次世代のプログラミング言語にも受け継がれる可能性の高い核となる機構，&lt;br /&gt;
プログラミングにおける持続可能性の高い知識とはなんだろうか．&lt;/p&gt;

&lt;p&gt;ようやく本題に辿り着いた．
&lt;a href=&quot;https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%91%E3%83%A9%E3%83%80%E3%82%A4%E3%83%A0&quot;&gt;プログラミングパラダイム&lt;/a&gt;という概念？について何度か調べようと試みたことがある．
おそらくここにこの問の答えがあるように思っていたからだ．
しかし(自分が理解していないので感覚的にしか言えないが)，各パラダイムは互いに排反なものではなく，各パラダイムの差異について言及されることが多いが，実のところ共通する部分も多く存在していそうであるという印象を受けた．
また，ある言語があるパラダイムの完全な実装となっていることはほぼなさそう？である．
特定のプログラミング言語からそれを構成するパラダイムを学ぶのは筋が悪いように感じた．
実装に伴う制約や歴史的背景などが複雑に絡み合っているのだろう．&lt;/p&gt;

&lt;p&gt;そこで俗にガウディ本と呼ばれている以下の本を読もうと思ったのである．&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ctmcp.jpg&quot; alt=&quot;&quot; /&gt;
&lt;a href=&quot;https://www.amazon.co.jp/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E6%A6%82%E5%BF%B5-%E6%8A%80%E6%B3%95-%E3%83%A2%E3%83%87%E3%83%AB-Architects-Archive%E3%82%AF%E3%83%A9%E3%82%B7%E3%83%83%E3%82%AF%E3%83%A2%E3%83%80%E3%83%B3-%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0-%E3%82%BB%E3%82%A4%E3%83%95-%E3%83%8F%E3%83%AA%E3%83%87%E3%82%A3/dp/4798113468/ref=sr_1_1?ie=UTF8&amp;amp;qid=1501215064&amp;amp;sr=8-1&amp;amp;keywords=%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E6%A6%82%E5%BF%B5&quot;&gt;『コンピュータプログラミングの概念・技法・モデル』&lt;/a&gt; 
(原題: 『Concepts,Techniques, and Models of Computer Programming』，CTMCPと略記される)という本である．
本の情報は自分がまだ読み終ってないので&lt;a href=&quot;https://www.amazon.co.jp/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E6%A6%82%E5%BF%B5-%E6%8A%80%E6%B3%95-%E3%83%A2%E3%83%87%E3%83%AB-Architects-Archive%E3%82%AF%E3%83%A9%E3%82%B7%E3%83%83%E3%82%AF%E3%83%A2%E3%83%80%E3%83%B3-%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0-%E3%82%BB%E3%82%A4%E3%83%95-%E3%83%8F%E3%83%AA%E3%83%87%E3%82%A3/dp/4798113468/ref=sr_1_1?ie=UTF8&amp;amp;qid=1501215064&amp;amp;sr=8-1&amp;amp;keywords=%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E6%A6%82%E5%BF%B5&quot;&gt;amazonの概要欄&lt;/a&gt;に譲る．
レビュー等を見ると，核言語(Kernel language)というプログラミングパラダイムを構成するプリミティヴに分解してそれぞれのプリミティヴを解説，その組み合わせでパラダイムが決定されているといった内容のようで，自分が求めていた物に近そうだと思う．
そこそこの厚さ(1000p弱)の本なのですぐには読み終わらないと思うが，100件以上投稿することはないだろうという甘い見立てで10進数で2桁の連番で感想・知見をまとめていこうと思う．&lt;/p&gt;</content><author><name>yto9</name></author><category term="Books" /><category term="CTMCP" /><category term="Log" /><category term="Diary" /><summary type="html">これまでにいくつかのプログラミング言語でプログラミングをしてきた． 初めてプログラミングを学んだのはC言語を用いてだった． C言語は現在ある高級言語の中ではシンプルな部類に入る言語である． 言語を構成している概念は少ない方だとは思うが，それでもプログラミングが初めての自分にとっては初めての概念ばかりだった． それなりに壁にぶつかりつつも色々とプログラミングについての知見を得ることができていると思っていた．</summary></entry><entry><title type="html">About this site</title><link href="http://ytoku.net/portfolio/about/" rel="alternate" type="text/html" title="About this site" /><published>2017-07-19T00:00:00+00:00</published><updated>2017-07-19T00:00:00+00:00</updated><id>http://ytoku.net/portfolio/about</id><content type="html" xml:base="http://ytoku.net/portfolio/about/">&lt;h2 id=&quot;purpose&quot;&gt;purpose&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;improve my documentation skill&lt;/li&gt;
  &lt;li&gt;do documentation and publication at the same time&lt;/li&gt;
  &lt;li&gt;lifelog&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;using-services&quot;&gt;using services&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Amazon S3 (static website hosting)&lt;/li&gt;
  &lt;li&gt;Jekyll&lt;br /&gt;
      - minimal mistakes&lt;/li&gt;
  &lt;li&gt;Docker&lt;/li&gt;
  &lt;li&gt;git&lt;/li&gt;
  &lt;li&gt;github/CircleCI&lt;/li&gt;
  &lt;li&gt;Inkscape&lt;/li&gt;
&lt;/ul&gt;</content><author><name>yto9</name></author><summary type="html">purpose improve my documentation skill do documentation and publication at the same time lifelog</summary></entry></feed>